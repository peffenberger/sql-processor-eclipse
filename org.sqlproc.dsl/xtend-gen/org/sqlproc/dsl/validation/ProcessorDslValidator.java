/**
 * generated by Xtext
 */
package org.sqlproc.dsl.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.scoping.IScopeProvider;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.sqlproc.dsl.processorDsl.Column;
import org.sqlproc.dsl.processorDsl.Constant;
import org.sqlproc.dsl.processorDsl.DatabaseColumn;
import org.sqlproc.dsl.processorDsl.DatabaseTable;
import org.sqlproc.dsl.processorDsl.Entity;
import org.sqlproc.dsl.processorDsl.EnumEntity;
import org.sqlproc.dsl.processorDsl.EnumProperty;
import org.sqlproc.dsl.processorDsl.FunctionDefinition;
import org.sqlproc.dsl.processorDsl.Identifier;
import org.sqlproc.dsl.processorDsl.MappingColumn;
import org.sqlproc.dsl.processorDsl.MappingRule;
import org.sqlproc.dsl.processorDsl.MetaSql;
import org.sqlproc.dsl.processorDsl.MetaStatement;
import org.sqlproc.dsl.processorDsl.OptionalFeature;
import org.sqlproc.dsl.processorDsl.PojoDao;
import org.sqlproc.dsl.processorDsl.PojoDefinition;
import org.sqlproc.dsl.processorDsl.PojoEntity;
import org.sqlproc.dsl.processorDsl.PojoProperty;
import org.sqlproc.dsl.processorDsl.PojoType;
import org.sqlproc.dsl.processorDsl.ProcedureDefinition;
import org.sqlproc.dsl.processorDsl.Property;
import org.sqlproc.dsl.processorDsl.TableDefinition;
import org.sqlproc.dsl.property.ModelProperty;
import org.sqlproc.dsl.resolver.DbResolver;
import org.sqlproc.dsl.resolver.PojoResolver;
import org.sqlproc.dsl.resolver.PojoResolverFactory;
import org.sqlproc.dsl.util.Utils;
import org.sqlproc.dsl.validation.AbstractProcessorDslValidator;
import org.sqlproc.dsl.validation.ValidationResult;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class ProcessorDslValidator extends AbstractProcessorDslValidator {
  @Inject
  private PojoResolverFactory pojoResolverFactory;
  
  @Inject
  private DbResolver dbResolver;
  
  @Inject
  private IScopeProvider scopeProvider;
  
  @Inject
  private IQualifiedNameConverter qualifiedNameConverter;
  
  @Inject
  private ModelProperty modelProperty;
  
  private final ArrayList<String> F_TYPES = CollectionLiterals.<String>newArrayList("set", "update", "values", "where", "columns", "set=opt", "where=opt");
  
  @Check
  public void checkMetaSqlFtype(final MetaSql metaSql) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nMETA_SQL__FTYPE cannot be resolved");
  }
  
  public boolean findInListIgnoreCase(final List<String> list, final String value) {
    boolean _equals = Objects.equal(list, null);
    if (_equals) {
      return false;
    }
    for (final String item : list) {
      boolean _equalsIgnoreCase = item.equalsIgnoreCase(value);
      if (_equalsIgnoreCase) {
        return true;
      }
    }
    return false;
  }
  
  @Check
  public void checkUniqueMetaStatement(final MetaStatement metaStatement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nMETA_STATEMENT__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniqueMappingRule(final MappingRule mappingRule) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nMAPPING_RULE__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniqueOptionalFeature(final OptionalFeature optionalFeature) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nOPTIONAL_FEATURE__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniquePojoDefinition(final PojoDefinition pojoDefinition) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nPOJO_DEFINITION__NAME cannot be resolved"
      + "\nPOJO_DEFINITION__NAME cannot be resolved");
  }
  
  public boolean equalsStatement(final MetaStatement statement1, final MetaStatement statement2) {
    boolean _and = false;
    boolean _equals = Objects.equal(statement1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(statement2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _or = false;
    boolean _equals_2 = Objects.equal(statement1, null);
    if (_equals_2) {
      _or = true;
    } else {
      String _name = statement1.getName();
      boolean _equals_3 = Objects.equal(_name, null);
      _or = _equals_3;
    }
    if (_or) {
      return false;
    }
    boolean _or_1 = false;
    boolean _equals_4 = Objects.equal(statement2, null);
    if (_equals_4) {
      _or_1 = true;
    } else {
      String _name_1 = statement2.getName();
      boolean _equals_5 = Objects.equal(_name_1, null);
      _or_1 = _equals_5;
    }
    if (_or_1) {
      return false;
    }
    boolean _and_1 = false;
    String _name_2 = statement1.getName();
    String _name_3 = statement2.getName();
    boolean _equals_6 = _name_2.equals(_name_3);
    if (!_equals_6) {
      _and_1 = false;
    } else {
      String _type = statement1.getType();
      String _type_1 = statement2.getType();
      boolean _equals_7 = _type.equals(_type_1);
      _and_1 = _equals_7;
    }
    if (_and_1) {
      EList<String> _modifiers = statement1.getModifiers();
      EList<String> _modifiers_1 = statement2.getModifiers();
      return this.equalsModifiers(_modifiers, _modifiers_1);
    }
    return false;
  }
  
  public boolean equalsRule(final MappingRule rule1, final MappingRule rule2) {
    boolean _and = false;
    boolean _equals = Objects.equal(rule1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(rule2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _or = false;
    boolean _equals_2 = Objects.equal(rule1, null);
    if (_equals_2) {
      _or = true;
    } else {
      String _name = rule1.getName();
      boolean _equals_3 = Objects.equal(_name, null);
      _or = _equals_3;
    }
    if (_or) {
      return false;
    }
    boolean _or_1 = false;
    boolean _equals_4 = Objects.equal(rule2, null);
    if (_equals_4) {
      _or_1 = true;
    } else {
      String _name_1 = rule2.getName();
      boolean _equals_5 = Objects.equal(_name_1, null);
      _or_1 = _equals_5;
    }
    if (_or_1) {
      return false;
    }
    boolean _and_1 = false;
    String _name_2 = rule1.getName();
    String _name_3 = rule2.getName();
    boolean _equals_6 = _name_2.equals(_name_3);
    if (!_equals_6) {
      _and_1 = false;
    } else {
      String _type = rule1.getType();
      String _type_1 = rule2.getType();
      boolean _equals_7 = _type.equals(_type_1);
      _and_1 = _equals_7;
    }
    if (_and_1) {
      EList<String> _modifiers = rule1.getModifiers();
      EList<String> _modifiers_1 = rule2.getModifiers();
      return this.equalsModifiers(_modifiers, _modifiers_1);
    }
    return false;
  }
  
  public boolean equalsFeature(final OptionalFeature feature1, final OptionalFeature feature2) {
    boolean _and = false;
    boolean _equals = Objects.equal(feature1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(feature2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _or = false;
    boolean _equals_2 = Objects.equal(feature1, null);
    if (_equals_2) {
      _or = true;
    } else {
      String _name = feature1.getName();
      boolean _equals_3 = Objects.equal(_name, null);
      _or = _equals_3;
    }
    if (_or) {
      return false;
    }
    boolean _or_1 = false;
    boolean _equals_4 = Objects.equal(feature2, null);
    if (_equals_4) {
      _or_1 = true;
    } else {
      String _name_1 = feature2.getName();
      boolean _equals_5 = Objects.equal(_name_1, null);
      _or_1 = _equals_5;
    }
    if (_or_1) {
      return false;
    }
    boolean _and_1 = false;
    String _name_2 = feature1.getName();
    String _name_3 = feature2.getName();
    boolean _equals_6 = _name_2.equals(_name_3);
    if (!_equals_6) {
      _and_1 = false;
    } else {
      String _type = feature1.getType();
      String _type_1 = feature2.getType();
      boolean _equals_7 = _type.equals(_type_1);
      _and_1 = _equals_7;
    }
    if (_and_1) {
      EList<String> _modifiers = feature1.getModifiers();
      EList<String> _modifiers_1 = feature2.getModifiers();
      return this.equalsModifiers(_modifiers, _modifiers_1);
    }
    return false;
  }
  
  public boolean equalsModifiers(final List<String> modifiers1, final List<String> modifiers2) {
    final List<String> filteredModifiers1 = this.filteredModifiers(modifiers1);
    final List<String> filteredModifiers2 = this.filteredModifiers(modifiers2);
    boolean _and = false;
    boolean _equals = Objects.equal(filteredModifiers1, null);
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(filteredModifiers2, null);
      _and = _equals_1;
    }
    if (_and) {
      return true;
    }
    boolean _equals_2 = Objects.equal(filteredModifiers1, null);
    if (_equals_2) {
      return false;
    }
    boolean _equals_3 = Objects.equal(filteredModifiers2, null);
    if (_equals_3) {
      return false;
    }
    boolean _and_1 = false;
    boolean _isEmpty = filteredModifiers1.isEmpty();
    if (!_isEmpty) {
      _and_1 = false;
    } else {
      boolean _isEmpty_1 = filteredModifiers2.isEmpty();
      _and_1 = _isEmpty_1;
    }
    if (_and_1) {
      return true;
    }
    for (final String modifier1 : filteredModifiers1) {
      for (final String modifier2 : filteredModifiers2) {
        boolean _equals_4 = modifier1.equals(modifier2);
        if (_equals_4) {
          return true;
        }
      }
    }
    return false;
  }
  
  public List<String> filteredModifiers(final List<String> modifiers) {
    boolean _equals = Objects.equal(modifiers, null);
    if (_equals) {
      return null;
    }
    final ArrayList<String> filteredModifiers = CollectionLiterals.<String>newArrayList();
    final Procedure1<String> _function = new Procedure1<String>() {
      public void apply(final String modifier) {
        int _indexOf = modifier.indexOf("=");
        boolean _lessThan = (_indexOf < 0);
        if (_lessThan) {
          filteredModifiers.add(modifier);
        }
      }
    };
    IterableExtensions.<String>forEach(modifiers, _function);
    return filteredModifiers;
  }
  
  public boolean checkClass(final String className) {
    boolean _or = false;
    boolean _equals = Objects.equal(className, null);
    if (_equals) {
      _or = true;
    } else {
      PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
      boolean _equals_1 = Objects.equal(_pojoResolver, null);
      _or = _equals_1;
    }
    if (_or) {
      return true;
    }
    PojoResolver _pojoResolver_1 = this.pojoResolverFactory.getPojoResolver();
    final Class<?> clazz = _pojoResolver_1.loadClass(className);
    return (!Objects.equal(clazz, null));
  }
  
  public boolean isResolvePojo(final EObject model) {
    boolean _or = false;
    PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
    boolean _equals = Objects.equal(_pojoResolver, null);
    if (_equals) {
      _or = true;
    } else {
      PojoResolver _pojoResolver_1 = this.pojoResolverFactory.getPojoResolver();
      boolean _isResolvePojo = _pojoResolver_1.isResolvePojo(model);
      boolean _not = (!_isResolvePojo);
      _or = _not;
    }
    if (_or) {
      return false;
    }
    return true;
  }
  
  public boolean isResolveDb(final EObject model) {
    return this.dbResolver.isResolveDb(model);
  }
  
  public String getClass(final PojoDefinition pojo) {
    JvmType _classx = pojo.getClassx();
    boolean _notEquals = (!Objects.equal(_classx, null));
    if (_notEquals) {
      JvmType _classx_1 = pojo.getClassx();
      return _classx_1.getQualifiedName();
    }
    return pojo.getClass_();
  }
  
  @Check
  public void checkColumn(final Column column) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nCOLUMN__COLUMNS cannot be resolved"
      + "\nCOLUMN__COLUMNS cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nCOLUMN__COLUMNS cannot be resolved"
      + "\nCOLUMN__COLUMNS cannot be resolved"
      + "\nCOLUMN__COLUMNS cannot be resolved");
  }
  
  @Check
  public void checkIdentifier(final Identifier identifier) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nIDENTIFIER__NAME cannot be resolved"
      + "\nIDENTIFIER__NAME cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nIDENTIFIER__NAME cannot be resolved"
      + "\nIDENTIFIER__NAME cannot be resolved"
      + "\nIDENTIFIER__NAME cannot be resolved");
  }
  
  @Check
  public void checkConstant(final Constant constant) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nCONSTANT__NAME cannot be resolved"
      + "\nCONSTANT__NAME cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nCONSTANT__NAME cannot be resolved"
      + "\nCONSTANT__NAME cannot be resolved"
      + "\nCONSTANT__NAME cannot be resolved");
  }
  
  @Check
  public void checkMappingColumn(final MappingColumn column) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nMAPPING_COLUMN__ITEMS cannot be resolved"
      + "\nMAPPING_COLUMN__ITEMS cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nMAPPING_COLUMN__ITEMS cannot be resolved"
      + "\nMAPPING_COLUMN__ITEMS cannot be resolved"
      + "\nMAPPING_COLUMN__ITEMS cannot be resolved");
  }
  
  @Check
  public void checkMetaStatement(final MetaStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nMETA_STATEMENT__MODIFIERS cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nMETA_STATEMENT__MODIFIERS cannot be resolved"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nMETA_STATEMENT__MODIFIERS cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nMETA_STATEMENT__MODIFIERS cannot be resolved"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nMETA_STATEMENT__MODIFIERS cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nMETA_STATEMENT__MODIFIERS cannot be resolved"
      + "\nARTIFACTS__TABLES cannot be resolved"
      + "\nMETA_STATEMENT__MODIFIERS cannot be resolved");
  }
  
  @Check
  public void checkMappingRule(final MappingRule rule) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__POJO_PACKAGES cannot be resolved"
      + "\nMAPPING_RULE__MODIFIERS cannot be resolved"
      + "\nARTIFACTS__POJOS cannot be resolved"
      + "\nMAPPING_RULE__MODIFIERS cannot be resolved");
  }
  
  public boolean isNumber(final String param) {
    boolean _equals = Objects.equal(param, null);
    if (_equals) {
      return false;
    }
    int _length = param.length();
    int i = (_length - 1);
    while ((i >= 0)) {
      {
        char _charAt = param.charAt(i);
        boolean _isDigit = Character.isDigit(_charAt);
        boolean _not = (!_isDigit);
        if (_not) {
          return false;
        }
        i = (i - 1);
      }
    }
    return true;
  }
  
  public boolean isPrimitive(final Class<?> clazz) {
    boolean _equals = Objects.equal(clazz, null);
    if (_equals) {
      return true;
    }
    boolean _equals_1 = Objects.equal(clazz, String.class);
    if (_equals_1) {
      return true;
    }
    boolean _equals_2 = Objects.equal(clazz, Date.class);
    if (_equals_2) {
      return true;
    }
    boolean _equals_3 = Objects.equal(clazz, java.sql.Date.class);
    if (_equals_3) {
      return true;
    }
    boolean _equals_4 = Objects.equal(clazz, Time.class);
    if (_equals_4) {
      return true;
    }
    boolean _equals_5 = Objects.equal(clazz, Timestamp.class);
    if (_equals_5) {
      return true;
    }
    boolean _equals_6 = Objects.equal(clazz, Blob.class);
    if (_equals_6) {
      return true;
    }
    boolean _equals_7 = Objects.equal(clazz, Clob.class);
    if (_equals_7) {
      return true;
    }
    boolean _equals_8 = Objects.equal(clazz, BigDecimal.class);
    if (_equals_8) {
      return true;
    }
    boolean _equals_9 = Objects.equal(clazz, BigInteger.class);
    if (_equals_9) {
      return true;
    }
    return false;
  }
  
  public ValidationResult checkClassProperty(final String className, final String property) {
    boolean _or = false;
    boolean _or_1 = false;
    boolean _equals = Objects.equal(property, null);
    if (_equals) {
      _or_1 = true;
    } else {
      boolean _isNumber = this.isNumber(property);
      _or_1 = _isNumber;
    }
    if (_or_1) {
      _or = true;
    } else {
      PojoResolver _pojoResolver = this.pojoResolverFactory.getPojoResolver();
      boolean _equals_1 = Objects.equal(_pojoResolver, null);
      _or = _equals_1;
    }
    if (_or) {
      return ValidationResult.OK;
    }
    boolean _equals_2 = Objects.equal(className, null);
    if (_equals_2) {
      return ValidationResult.ERROR;
    }
    PojoResolver _pojoResolver_1 = this.pojoResolverFactory.getPojoResolver();
    PropertyDescriptor[] descriptors = _pojoResolver_1.getPropertyDescriptors(className);
    boolean _equals_3 = Objects.equal(descriptors, null);
    if (_equals_3) {
      return ValidationResult.WARNING;
    }
    String checkProperty = property;
    int pos1 = checkProperty.indexOf("=");
    if ((pos1 > 0)) {
      int pos2 = checkProperty.indexOf(".", pos1);
      if ((pos2 > pos1)) {
        String _substring = checkProperty.substring(0, pos1);
        String _substring_1 = checkProperty.substring(pos2);
        String _plus = (_substring + _substring_1);
        checkProperty = _plus;
      }
    }
    String innerProperty = ((String) null);
    int _indexOf = checkProperty.indexOf(".");
    pos1 = _indexOf;
    if ((pos1 > 0)) {
      String _substring_2 = checkProperty.substring((pos1 + 1));
      innerProperty = _substring_2;
      String _substring_3 = checkProperty.substring(0, pos1);
      checkProperty = _substring_3;
    }
    final String _checkProperty = checkProperty;
    final PropertyDescriptor[] _converted_descriptors = (PropertyDescriptor[])descriptors;
    final Function1<PropertyDescriptor, Boolean> _function = new Function1<PropertyDescriptor, Boolean>() {
      public Boolean apply(final PropertyDescriptor descriptor) {
        String _name = descriptor.getName();
        return Boolean.valueOf(Objects.equal(_name, _checkProperty));
      }
    };
    PropertyDescriptor innerDesriptor = IterableExtensions.<PropertyDescriptor>findFirst(((Iterable<PropertyDescriptor>)Conversions.doWrapArray(_converted_descriptors)), _function);
    boolean _equals_4 = Objects.equal(innerDesriptor, null);
    if (_equals_4) {
      PojoResolver _pojoResolver_2 = this.pojoResolverFactory.getPojoResolver();
      final Class<?> clazz = _pojoResolver_2.loadClass(className);
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(clazz, null));
      if (!_notEquals) {
        _and = false;
      } else {
        int _modifiers = clazz.getModifiers();
        boolean _isAbstract = Modifier.isAbstract(_modifiers);
        _and = _isAbstract;
      }
      if (_and) {
        return ValidationResult.WARNING;
      }
      return ValidationResult.ERROR;
    }
    boolean _notEquals_1 = (!Objects.equal(innerProperty, null));
    if (_notEquals_1) {
      Class<?> innerClass = innerDesriptor.getPropertyType();
      boolean _isArray = innerClass.isArray();
      if (_isArray) {
        Method _readMethod = innerDesriptor.getReadMethod();
        Type _genericReturnType = _readMethod.getGenericReturnType();
        final ParameterizedType type = ((ParameterizedType) _genericReturnType);
        boolean _or_2 = false;
        Type[] _actualTypeArguments = type.getActualTypeArguments();
        boolean _equals_5 = Objects.equal(_actualTypeArguments, null);
        if (_equals_5) {
          _or_2 = true;
        } else {
          Type[] _actualTypeArguments_1 = type.getActualTypeArguments();
          int _length = _actualTypeArguments_1.length;
          boolean _equals_6 = (_length == 0);
          _or_2 = _equals_6;
        }
        if (_or_2) {
          return ValidationResult.WARNING;
        }
        Type[] _actualTypeArguments_2 = type.getActualTypeArguments();
        Type _head = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(_actualTypeArguments_2)));
        innerClass = ((Class<?>) _head);
        boolean _isPrimitive = this.isPrimitive(innerClass);
        if (_isPrimitive) {
          return ValidationResult.ERROR;
        }
        String _name = innerClass.getName();
        return this.checkClassProperty(_name, innerProperty);
      } else {
        boolean _isAssignableFrom = Collection.class.isAssignableFrom(innerClass);
        if (_isAssignableFrom) {
          Method _readMethod_1 = innerDesriptor.getReadMethod();
          Type _genericReturnType_1 = _readMethod_1.getGenericReturnType();
          final ParameterizedType type_1 = ((ParameterizedType) _genericReturnType_1);
          boolean _or_3 = false;
          Type[] _actualTypeArguments_3 = type_1.getActualTypeArguments();
          boolean _equals_7 = Objects.equal(_actualTypeArguments_3, null);
          if (_equals_7) {
            _or_3 = true;
          } else {
            Type[] _actualTypeArguments_4 = type_1.getActualTypeArguments();
            int _length_1 = _actualTypeArguments_4.length;
            boolean _equals_8 = (_length_1 == 0);
            _or_3 = _equals_8;
          }
          if (_or_3) {
            return ValidationResult.WARNING;
          }
          Type[] _actualTypeArguments_5 = type_1.getActualTypeArguments();
          Type _head_1 = IterableExtensions.<Type>head(((Iterable<Type>)Conversions.doWrapArray(_actualTypeArguments_5)));
          innerClass = ((Class<?>) _head_1);
          boolean _isPrimitive_1 = this.isPrimitive(innerClass);
          if (_isPrimitive_1) {
            return ValidationResult.ERROR;
          }
          String _name_1 = innerClass.getName();
          return this.checkClassProperty(_name_1, innerProperty);
        } else {
          boolean _isPrimitive_2 = this.isPrimitive(innerClass);
          if (_isPrimitive_2) {
            return ValidationResult.ERROR;
          }
          String _name_2 = innerClass.getName();
          return this.checkClassProperty(_name_2, innerProperty);
        }
      }
    }
    return ValidationResult.OK;
  }
  
  public ValidationResult checkEntityProperty(final PojoEntity entity, final String property) {
    boolean _or = false;
    boolean _equals = Objects.equal(property, null);
    if (_equals) {
      _or = true;
    } else {
      boolean _isNumber = this.isNumber(property);
      _or = _isNumber;
    }
    if (_or) {
      return ValidationResult.OK;
    }
    String checkProperty = property;
    int pos1 = checkProperty.indexOf("=");
    if ((pos1 > 0)) {
      int pos2 = checkProperty.indexOf(".", pos1);
      if ((pos2 > pos1)) {
        String _substring = checkProperty.substring(0, pos1);
        String _substring_1 = checkProperty.substring(pos2);
        String _plus = (_substring + _substring_1);
        checkProperty = _plus;
      }
    }
    String innerProperty = ((String) null);
    int _indexOf = checkProperty.indexOf(".");
    pos1 = _indexOf;
    if ((pos1 > 0)) {
      String _substring_2 = checkProperty.substring((pos1 + 1));
      innerProperty = _substring_2;
      String _substring_3 = checkProperty.substring(0, pos1);
      checkProperty = _substring_3;
    }
    EList<PojoProperty> _features = entity.getFeatures();
    for (final PojoProperty pojoProperty : _features) {
      String _name = pojoProperty.getName();
      boolean _equals_1 = _name.equals(checkProperty);
      if (_equals_1) {
        boolean _equals_2 = Objects.equal(innerProperty, null);
        if (_equals_2) {
          return ValidationResult.OK;
        }
        PojoType _type = pojoProperty.getType();
        Entity _ref = _type.getRef();
        boolean _notEquals = (!Objects.equal(_ref, null));
        if (_notEquals) {
          PojoType _type_1 = pojoProperty.getType();
          Entity _ref_1 = _type_1.getRef();
          if ((_ref_1 instanceof PojoEntity)) {
            PojoType _type_2 = pojoProperty.getType();
            Entity _ref_2 = _type_2.getRef();
            return this.checkEntityProperty(((PojoEntity) _ref_2), innerProperty);
          }
          return ValidationResult.OK;
        }
        boolean _and = false;
        PojoType _type_3 = pojoProperty.getType();
        Entity _gref = _type_3.getGref();
        boolean _notEquals_1 = (!Objects.equal(_gref, null));
        if (!_notEquals_1) {
          _and = false;
        } else {
          PojoType _type_4 = pojoProperty.getType();
          Entity _gref_1 = _type_4.getGref();
          _and = (_gref_1 instanceof PojoEntity);
        }
        if (_and) {
          PojoType _type_5 = pojoProperty.getType();
          Entity _gref_2 = _type_5.getGref();
          return this.checkEntityProperty(((PojoEntity) _gref_2), innerProperty);
        }
        return ValidationResult.ERROR;
      }
    }
    PojoType superType = Utils.getSuperType(entity);
    boolean _and_1 = false;
    boolean _notEquals_2 = (!Objects.equal(superType, null));
    if (!_notEquals_2) {
      _and_1 = false;
    } else {
      _and_1 = (superType instanceof PojoEntity);
    }
    if (_and_1) {
      ValidationResult result = this.checkEntityProperty(((PojoEntity) superType), property);
      boolean _or_1 = false;
      boolean _equals_3 = Objects.equal(result, ValidationResult.WARNING);
      if (_equals_3) {
        _or_1 = true;
      } else {
        boolean _equals_4 = Objects.equal(result, ValidationResult.OK);
        _or_1 = _equals_4;
      }
      if (_or_1) {
        return result;
      }
    }
    boolean _isAbstract = Utils.isAbstract(entity);
    if (_isAbstract) {
      return ValidationResult.WARNING;
    } else {
      final Set<String> suppressedAbstracts = this.modelProperty.getNotAbstractTables(entity);
      boolean _and_2 = false;
      boolean _notEquals_3 = (!Objects.equal(suppressedAbstracts, null));
      if (!_notEquals_3) {
        _and_2 = false;
      } else {
        String _dbName = Utils.dbName(entity);
        boolean _contains = suppressedAbstracts.contains(_dbName);
        _and_2 = _contains;
      }
      if (_and_2) {
        return ValidationResult.WARNING;
      } else {
        return ValidationResult.ERROR;
      }
    }
  }
  
  @Check
  public void checkUniqueProperty(final Property property) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nPROPERTY__NAME cannot be resolved");
  }
  
  @Check
  public void checkTableDefinition(final TableDefinition tableDefinition) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nTABLE_DEFINITION__NAME cannot be resolved"
      + "\nTABLE_DEFINITION__TABLE cannot be resolved");
  }
  
  @Check
  public void checkProcedureDefinition(final ProcedureDefinition procedureDefinition) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nPROCEDURE_DEFINITION__NAME cannot be resolved"
      + "\nPROCEDURE_DEFINITION__NAME cannot be resolved");
  }
  
  @Check
  public void checkFunctionDefinition(final FunctionDefinition functionDefinition) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nFUNCTION_DEFINITION__NAME cannot be resolved");
  }
  
  @Check
  public void checkDatabaseColumn(final DatabaseColumn databaseColumn) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__TABLES cannot be resolved"
      + "\nDATABASE_COLUMN__NAME cannot be resolved");
  }
  
  @Check
  public void checkDatabaseTable(final DatabaseTable databaseTable) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nARTIFACTS__TABLES cannot be resolved"
      + "\nDATABASE_TABLE__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniquePojoEntity(final PojoEntity pojoEntity) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nENTITY__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniquePojoProperty(final PojoProperty pojoProperty) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nPOJO_PROPERTY__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniqueEnumEntity(final EnumEntity enumEntity) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nENTITY__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniqueEnumProperty(final EnumProperty enumProperty) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nENUM_PROPERTY__NAME cannot be resolved");
  }
  
  @Check
  public void checkUniquePojoDao(final PojoDao pojoDao) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method Literals is undefined for the type ProcessorDslValidator"
      + "\nPOJO_DAO__NAME cannot be resolved");
  }
}
