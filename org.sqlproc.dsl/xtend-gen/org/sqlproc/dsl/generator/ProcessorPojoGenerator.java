/**
 * generated by Xtext
 */
package org.sqlproc.dsl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.sqlproc.dsl.ImportManager;
import org.sqlproc.dsl.generator.ProcessorGeneratorUtils;
import org.sqlproc.dsl.processorDsl.Annotation;
import org.sqlproc.dsl.processorDsl.AnnotationProperty;
import org.sqlproc.dsl.processorDsl.Entity;
import org.sqlproc.dsl.processorDsl.EnumDirective;
import org.sqlproc.dsl.processorDsl.EnumEntity;
import org.sqlproc.dsl.processorDsl.EnumProperty;
import org.sqlproc.dsl.processorDsl.EnumPropertyDirectiveValues;
import org.sqlproc.dsl.processorDsl.EnumPropertyValue;
import org.sqlproc.dsl.processorDsl.Extends;
import org.sqlproc.dsl.processorDsl.Implements;
import org.sqlproc.dsl.processorDsl.PojoDirective;
import org.sqlproc.dsl.processorDsl.PojoDirectiveIsDef;
import org.sqlproc.dsl.processorDsl.PojoDirectiveToInit;
import org.sqlproc.dsl.processorDsl.PojoEntity;
import org.sqlproc.dsl.processorDsl.PojoProperty;
import org.sqlproc.dsl.processorDsl.PojoType;
import org.sqlproc.dsl.util.Utils;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class ProcessorPojoGenerator {
  @Inject
  @Extension
  private IQualifiedNameProvider _iQualifiedNameProvider;
  
  @Inject
  @Extension
  private ProcessorGeneratorUtils _processorGeneratorUtils;
  
  public CharSequence compile(final Entity e) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if ((e instanceof EnumEntity)) {
        CharSequence _compile = this.compile(((EnumEntity) e));
        _builder.append(_compile, "");
      } else {
        if ((e instanceof PojoEntity)) {
          CharSequence _compile_1 = this.compile(((PojoEntity) e));
          _builder.append(_compile_1, "");
        }
      }
    }
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final EnumEntity e) {
    StringConcatenation _builder = new StringConcatenation();
    final ImportManager im = new ImportManager(true);
    _builder.newLineIfNotEmpty();
    final EnumProperty eattr = Utils.getEnumAttr(e);
    _builder.newLineIfNotEmpty();
    this.addImplements(e, im);
    _builder.newLineIfNotEmpty();
    this.addExtends(e, im);
    _builder.newLineIfNotEmpty();
    final CharSequence classBody = this.compile(e, im, eattr);
    _builder.newLineIfNotEmpty();
    {
      EObject _eContainer = e.eContainer();
      boolean _notEquals = (!Objects.equal(_eContainer, null));
      if (_notEquals) {
        _builder.append("package ");
        EObject _eContainer_1 = e.eContainer();
        EObject _eContainer_2 = _eContainer_1.eContainer();
        QualifiedName _fullyQualifiedName = this._iQualifiedNameProvider.getFullyQualifiedName(_eContainer_2);
        _builder.append(_fullyQualifiedName, "");
        _builder.append(";");
      }
    }
    _builder.newLineIfNotEmpty();
    {
      List<String> _imports = im.getImports();
      boolean _isEmpty = _imports.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.newLine();
        {
          List<String> _imports_1 = im.getImports();
          for(final String i : _imports_1) {
            _builder.append("import ");
            _builder.append(i, "");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      String _sernum = Utils.getSernum(e);
      boolean _notEquals_1 = (!Objects.equal(_sernum, null));
      if (_notEquals_1) {
        _builder.newLine();
        _builder.append("import java.io.Serializable;");
        _builder.newLine();
      }
    }
    {
      EList<EnumProperty> _features = e.getFeatures();
      boolean _isEmpty_1 = _features.isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      if (_not_1) {
        _builder.append("import java.util.HashMap;");
        _builder.newLine();
        _builder.append("import java.util.Map;");
        _builder.newLine();
      }
    }
    _builder.newLine();
    _builder.append(classBody, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final EnumEntity e, final ImportManager im, final EnumProperty ea) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public enum ");
    String _name = e.getName();
    _builder.append(_name, "");
    _builder.append(" ");
    CharSequence _compileImplements = this.compileImplements(e);
    _builder.append(_compileImplements, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    {
      EList<EnumDirective> _directives = e.getDirectives();
      final Function1<EnumDirective, Boolean> _function = new Function1<EnumDirective, Boolean>() {
        public Boolean apply(final EnumDirective x) {
          return Boolean.valueOf((x instanceof EnumPropertyDirectiveValues));
        }
      };
      Iterable<EnumDirective> _filter = IterableExtensions.<EnumDirective>filter(_directives, _function);
      boolean _hasElements = false;
      for(final EnumDirective f : _filter) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(", ", "\t");
        }
        {
          EList<EnumPropertyValue> _values = ((EnumPropertyDirectiveValues) f).getValues();
          boolean _hasElements_1 = false;
          for(final EnumPropertyValue v : _values) {
            if (!_hasElements_1) {
              _hasElements_1 = true;
            } else {
              _builder.appendImmediate(", ", "\t");
            }
            String _name_1 = v.getName();
            _builder.append(_name_1, "\t");
            _builder.append("(");
            String _value = v.getValue();
            _builder.append(_value, "\t");
            _builder.append(")");
          }
        }
      }
    }
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    {
      String _sernum = Utils.getSernum(e);
      boolean _notEquals = (!Objects.equal(_sernum, null));
      if (_notEquals) {
        _builder.append("\t");
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("private static final long serialVersionUID = ");
        String _sernum_1 = Utils.getSernum(e);
        _builder.append(_sernum_1, "\t");
        _builder.append("L;");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private static Map<");
    CharSequence _compileType = this._processorGeneratorUtils.compileType(ea, im);
    _builder.append(_compileType, "\t");
    _builder.append(", ");
    String _name_2 = e.getName();
    _builder.append(_name_2, "\t");
    _builder.append("> identifierMap = new HashMap<");
    CharSequence _compileType_1 = this._processorGeneratorUtils.compileType(ea, im);
    _builder.append(_compileType_1, "\t");
    _builder.append(", ");
    String _name_3 = e.getName();
    _builder.append(_name_3, "\t");
    _builder.append(">();");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("static {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (");
    String _name_4 = e.getName();
    _builder.append(_name_4, "\t\t");
    _builder.append(" value : ");
    String _name_5 = e.getName();
    _builder.append(_name_5, "\t\t");
    _builder.append(".values()) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("identifierMap.put(value.getValue(), value);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private ");
    CharSequence _compileType_2 = this._processorGeneratorUtils.compileType(ea, im);
    _builder.append(_compileType_2, "\t");
    _builder.append(" ");
    String _name_6 = ea.getName();
    _builder.append(_name_6, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private ");
    String _name_7 = e.getName();
    _builder.append(_name_7, "\t");
    _builder.append("(");
    CharSequence _compileType_3 = this._processorGeneratorUtils.compileType(ea, im);
    _builder.append(_compileType_3, "\t");
    _builder.append(" value) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("this.");
    String _name_8 = ea.getName();
    _builder.append(_name_8, "\t\t");
    _builder.append(" = value;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static ");
    String _name_9 = e.getName();
    _builder.append(_name_9, "\t");
    _builder.append(" fromValue(");
    CharSequence _compileType_4 = this._processorGeneratorUtils.compileType(ea, im);
    _builder.append(_compileType_4, "\t");
    _builder.append(" value) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    String _name_10 = e.getName();
    _builder.append(_name_10, "\t\t");
    _builder.append(" result = identifierMap.get(value);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("if (result == null) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new IllegalArgumentException(\"No ");
    String _name_11 = e.getName();
    _builder.append(_name_11, "\t\t\t");
    _builder.append(" for value: \" + value);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return result;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public ");
    CharSequence _compileType_5 = this._processorGeneratorUtils.compileType(ea, im);
    _builder.append(_compileType_5, "\t");
    _builder.append(" getValue() {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("return ");
    String _name_12 = ea.getName();
    _builder.append(_name_12, "\t\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public String getName() {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return name();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final PojoEntity e) {
    StringConcatenation _builder = new StringConcatenation();
    final ImportManager im = new ImportManager(true);
    _builder.newLineIfNotEmpty();
    this.addImplements(e, im);
    _builder.newLineIfNotEmpty();
    this.addExtends(e, im);
    _builder.newLineIfNotEmpty();
    final CharSequence classBody = this.compile(e, im);
    _builder.newLineIfNotEmpty();
    {
      EObject _eContainer = e.eContainer();
      boolean _notEquals = (!Objects.equal(_eContainer, null));
      if (_notEquals) {
        _builder.append("package ");
        EObject _eContainer_1 = e.eContainer();
        EObject _eContainer_2 = _eContainer_1.eContainer();
        QualifiedName _fullyQualifiedName = this._iQualifiedNameProvider.getFullyQualifiedName(_eContainer_2);
        _builder.append(_fullyQualifiedName, "");
        _builder.append(";");
      }
    }
    _builder.newLineIfNotEmpty();
    {
      List<String> _imports = im.getImports();
      boolean _isEmpty = _imports.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("\t");
        _builder.newLine();
        {
          List<String> _imports_1 = im.getImports();
          for(final String i : _imports_1) {
            _builder.append("import ");
            _builder.append(i, "");
            _builder.append(";");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      String _sernum = Utils.getSernum(e);
      boolean _notEquals_1 = (!Objects.equal(_sernum, null));
      if (_notEquals_1) {
        _builder.newLine();
        _builder.append("import java.io.Serializable;");
        _builder.newLine();
      }
    }
    {
      List<PojoProperty> _listFeatures = this.listFeatures(e);
      boolean _isEmpty_1 = _listFeatures.isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      if (_not_1) {
        _builder.append("import java.util.ArrayList;");
        _builder.newLine();
      }
    }
    {
      boolean _or = false;
      PojoDirective _hasIsDef = this.hasIsDef(e);
      boolean _notEquals_2 = (!Objects.equal(_hasIsDef, null));
      if (_notEquals_2) {
        _or = true;
      } else {
        PojoDirective _hasToInit = this.hasToInit(e);
        boolean _notEquals_3 = (!Objects.equal(_hasToInit, null));
        _or = _notEquals_3;
      }
      if (_or) {
        _builder.append("import java.util.Set;");
        _builder.newLine();
        _builder.append("import java.util.HashSet;");
        _builder.newLine();
        _builder.append("import java.lang.reflect.InvocationTargetException;");
        _builder.newLine();
        _builder.append("import org.apache.commons.beanutils.MethodUtils;");
        _builder.newLine();
      }
    }
    {
      boolean _and = false;
      boolean _hasOperators = Utils.hasOperators(e);
      if (!_hasOperators) {
        _and = false;
      } else {
        String _operatorsSuffix = Utils.getOperatorsSuffix(e);
        boolean _equals = Objects.equal(_operatorsSuffix, null);
        _and = _equals;
      }
      if (_and) {
        _builder.append("import java.util.Map;");
        _builder.newLine();
        _builder.append("import java.util.HashMap;");
        _builder.newLine();
      }
    }
    _builder.newLine();
    _builder.append(classBody, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final PojoEntity e, final ImportManager im) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field ae is undefined for the type ProcessorPojoGenerator"
      + "\nname cannot be resolved"
      + "\nequalsIgnoreCase cannot be resolved"
      + "\ncompileHashCode cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequalsIgnoreCase cannot be resolved"
      + "\ncompileEquals cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequalsIgnoreCase cannot be resolved"
      + "\ncompileToInit cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequalsIgnoreCase cannot be resolved"
      + "\ncompileEnumInit cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequalsIgnoreCase cannot be resolved"
      + "\ncompileIsDef cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequalsIgnoreCase cannot be resolved"
      + "\ncompileEnumDef cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequalsIgnoreCase cannot be resolved"
      + "\ncompileToString cannot be resolved");
  }
  
  public CharSequence compileAnnotationProperty(final AnnotationProperty f, final ImportManager im) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = f.getName();
    _builder.append(_name, "");
    _builder.append(" = ");
    PojoType _type = f.getType();
    CharSequence _serialize = im.serialize(_type);
    _builder.append(_serialize, "");
    String _annotationValue = Utils.getAnnotationValue(f);
    _builder.append(_annotationValue, "");
    return _builder;
  }
  
  public CharSequence compile(final PojoProperty f, final ImportManager im, final PojoEntity e, final String operatorSuffix) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field aaf is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field aaf is undefined for the type ProcessorPojoGenerator"
      + "\nThe method or field aaf is undefined for the type ProcessorPojoGenerator"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\ngetterAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nsetterAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved");
  }
  
  public CharSequence compileHashCode(final PojoProperty f, final /* PojoAnnotatedProperty */Object aaf, final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method attrs is undefined for the type ProcessorPojoGenerator"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nnative cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  public CharSequence compileEquals(final PojoProperty f, final /* PojoAnnotatedProperty */Object aaf, final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method attrs is undefined for the type ProcessorPojoGenerator"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nnative cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  public CharSequence compileToString(final PojoProperty f, final /* PojoAnnotatedProperty */Object aaf, final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method attrs is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  public CharSequence compileIsDef(final PojoProperty f, final /* PojoAnnotatedProperty */Object aaf, final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method attrs is undefined for the type ProcessorPojoGenerator"
      + "\nname cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved");
  }
  
  public CharSequence compileEnumDef(final PojoProperty f, final /* PojoAnnotatedProperty */Object aaf, final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method attrs is undefined for the type ProcessorPojoGenerator"
      + "\nname cannot be resolved");
  }
  
  public CharSequence compileToInit(final PojoProperty f, final /* PojoAnnotatedProperty */Object aaf, final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method attrs is undefined for the type ProcessorPojoGenerator"
      + "\nname cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nattributeAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved");
  }
  
  public CharSequence compileEnumInit(final PojoProperty f, final /* PojoAnnotatedProperty */Object aaf, final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method attrs is undefined for the type ProcessorPojoGenerator"
      + "\nname cannot be resolved");
  }
  
  public CharSequence compileOperators(final ImportManager im, final PojoEntity e, final /* AnnotatedEntity */Object ae) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nThe method feature is undefined for the type ProcessorPojoGenerator"
      + "\nname cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nconflictAnnotations cannot be resolved"
      + "\ngetType cannot be resolved"
      + "\nfeatures cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeatures cannot be resolved");
  }
  
  public List<PojoProperty> listFeatures(final PojoEntity e) {
    final ArrayList<PojoProperty> list = new ArrayList<PojoProperty>();
    final PojoType se = Utils.getSuperType(e);
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(se, null));
    if (!_notEquals) {
      _and = false;
    } else {
      _and = (se instanceof PojoEntity);
    }
    if (_and) {
      List<PojoProperty> _listFeatures = this.listFeatures(((PojoEntity) se));
      list.addAll(_listFeatures);
    }
    List<PojoProperty> _listFeatures1 = this.listFeatures1(e);
    list.addAll(_listFeatures1);
    return list;
  }
  
  public List<PojoProperty> listFeatures1(final PojoEntity e) {
    EList<PojoProperty> _features = e.getFeatures();
    final Function1<PojoProperty, Boolean> _function = new Function1<PojoProperty, Boolean>() {
      public Boolean apply(final PojoProperty f) {
        return Boolean.valueOf(Utils.isList(f));
      }
    };
    Iterable<PojoProperty> _filter = IterableExtensions.<PojoProperty>filter(_features, _function);
    return IterableExtensions.<PojoProperty>toList(_filter);
  }
  
  public List<PojoProperty> requiredFeatures(final PojoEntity e) {
    final ArrayList<PojoProperty> list = new ArrayList<PojoProperty>();
    final PojoType se = Utils.getSuperType(e);
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(se, null));
    if (!_notEquals) {
      _and = false;
    } else {
      _and = (se instanceof PojoEntity);
    }
    if (_and) {
      List<PojoProperty> _requiredFeatures = this.requiredFeatures(((PojoEntity) se));
      list.addAll(_requiredFeatures);
    }
    List<PojoProperty> _requiredFeatures1 = this.requiredFeatures1(e);
    list.addAll(_requiredFeatures1);
    return list;
  }
  
  public ArrayList<PojoProperty> requiredSuperFeatures(final PojoEntity e) {
    final ArrayList<PojoProperty> list = new ArrayList<PojoProperty>();
    final PojoType se = Utils.getSuperType(e);
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(se, null));
    if (!_notEquals) {
      _and = false;
    } else {
      _and = (se instanceof PojoEntity);
    }
    if (_and) {
      List<PojoProperty> _requiredFeatures = this.requiredFeatures(((PojoEntity) se));
      list.addAll(_requiredFeatures);
    }
    return list;
  }
  
  public List<PojoProperty> requiredFeatures1(final PojoEntity e) {
    EList<PojoProperty> _features = e.getFeatures();
    final Function1<PojoProperty, Boolean> _function = new Function1<PojoProperty, Boolean>() {
      public Boolean apply(final PojoProperty f) {
        return Boolean.valueOf(Utils.isRequired(f));
      }
    };
    Iterable<PojoProperty> _filter = IterableExtensions.<PojoProperty>filter(_features, _function);
    return IterableExtensions.<PojoProperty>toList(_filter);
  }
  
  public PojoDirective hasIsDef(final PojoEntity e) {
    EList<PojoDirective> _directives = e.getDirectives();
    final Function1<PojoDirective, Boolean> _function = new Function1<PojoDirective, Boolean>() {
      public Boolean apply(final PojoDirective f) {
        return Boolean.valueOf((f instanceof PojoDirectiveIsDef));
      }
    };
    return IterableExtensions.<PojoDirective>findFirst(_directives, _function);
  }
  
  public PojoDirective hasToInit(final PojoEntity e) {
    EList<PojoDirective> _directives = e.getDirectives();
    final Function1<PojoDirective, Boolean> _function = new Function1<PojoDirective, Boolean>() {
      public Boolean apply(final PojoDirective f) {
        return Boolean.valueOf((f instanceof PojoDirectiveToInit));
      }
    };
    return IterableExtensions.<PojoDirective>findFirst(_directives, _function);
  }
  
  public boolean isAttribute(final PojoProperty f) {
    PojoType _type = f.getType();
    return (!Objects.equal(_type, null));
  }
  
  public CharSequence compileImplements(final EnumEntity e) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _sernum = Utils.getSernum(e);
      boolean _notEquals = (!Objects.equal(_sernum, null));
      if (_notEquals) {
        _builder.append("implements Serializable");
      }
    }
    _builder.append(" ");
    return _builder;
  }
  
  public CharSequence compileExtends(final PojoEntity e, final ImportManager im) {
    throw new Error("Unresolved compilation problems:"
      + "\nType mismatch: cannot convert from PojoType to PojoEntity"
      + "\n!= cannot be resolved");
  }
  
  public CharSequence compileImplements(final PojoEntity e) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method simpleName is undefined for the type ProcessorPojoGenerator");
  }
  
  public boolean compile(final Extends e, final ImportManager im) {
    PojoType _extends = e.getExtends();
    return im.addImportFor(_extends);
  }
  
  public void addImplements(final EnumEntity e, final ImportManager im) {
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Implements> _filter = Iterables.<Implements>filter(_eContents, Implements.class);
    for (final Implements impl : _filter) {
      PojoType _implements = impl.getImplements();
      im.addImportFor(_implements);
    }
  }
  
  public void addExtends(final EnumEntity e, final ImportManager im) {
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Extends> _filter = Iterables.<Extends>filter(_eContents, Extends.class);
    for (final Extends ext : _filter) {
      PojoType _extends = ext.getExtends();
      im.addImportFor(_extends);
    }
  }
  
  public void addImplements(final PojoEntity e, final ImportManager im) {
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Implements> _filter = Iterables.<Implements>filter(_eContents, Implements.class);
    for (final Implements impl : _filter) {
      PojoType _implements = impl.getImplements();
      im.addImportFor(_implements);
    }
  }
  
  public void addExtends(final PojoEntity e, final ImportManager im) {
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Extends> _filter = Iterables.<Extends>filter(_eContents, Extends.class);
    for (final Extends ext : _filter) {
      PojoType _extends = ext.getExtends();
      im.addImportFor(_extends);
    }
  }
  
  public void addAnnotations(final List<Annotation> annotations, final ImportManager im) {
    for (final Annotation a : annotations) {
      PojoType _type = a.getType();
      im.serialize(_type);
    }
  }
  
  public Object getExtends(final EnumEntity e) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method simpleName is undefined for the type ProcessorPojoGenerator");
  }
  
  public boolean isImplements(final EnumEntity e) {
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Implements> _filter = Iterables.<Implements>filter(_eContents, Implements.class);
    for (final Implements ext : _filter) {
      return true;
    }
    return false;
  }
  
  public boolean isExtends(final PojoEntity e) {
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Extends> _filter = Iterables.<Extends>filter(_eContents, Extends.class);
    for (final Extends ext : _filter) {
      {
        EList<PojoEntity> _onlyPojos = ext.getOnlyPojos();
        boolean _isEmpty = _onlyPojos.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          EList<PojoEntity> _onlyPojos_1 = ext.getOnlyPojos();
          for (final PojoEntity ee : _onlyPojos_1) {
            String _name = ee.getName();
            String _name_1 = e.getName();
            boolean _equals = Objects.equal(_name, _name_1);
            if (_equals) {
              return true;
            }
          }
          return false;
        }
        EList<PojoEntity> _exceptPojos = ext.getExceptPojos();
        for (final PojoEntity ee_1 : _exceptPojos) {
          String _name_2 = ee_1.getName();
          String _name_3 = e.getName();
          boolean _equals_1 = Objects.equal(_name_2, _name_3);
          if (_equals_1) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  }
  
  public boolean isExtends(final PojoEntity e, final Extends ext) {
    EList<PojoEntity> _onlyPojos = ext.getOnlyPojos();
    boolean _isEmpty = _onlyPojos.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      EList<PojoEntity> _onlyPojos_1 = ext.getOnlyPojos();
      for (final PojoEntity ee : _onlyPojos_1) {
        String _name = ee.getName();
        String _name_1 = e.getName();
        boolean _equals = Objects.equal(_name, _name_1);
        if (_equals) {
          return true;
        }
      }
      return false;
    }
    EList<PojoEntity> _exceptPojos = ext.getExceptPojos();
    for (final PojoEntity ee_1 : _exceptPojos) {
      String _name_2 = ee_1.getName();
      String _name_3 = e.getName();
      boolean _equals_1 = Objects.equal(_name_2, _name_3);
      if (_equals_1) {
        return false;
      }
    }
    return true;
  }
  
  public Object getExtends(final PojoEntity e) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method simpleName is undefined for the type ProcessorPojoGenerator");
  }
  
  public boolean isImplements(final PojoEntity e) {
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Implements> _filter = Iterables.<Implements>filter(_eContents, Implements.class);
    for (final Implements ext : _filter) {
      {
        EList<PojoEntity> _exceptPojos = ext.getExceptPojos();
        for (final PojoEntity ee : _exceptPojos) {
          String _name = ee.getName();
          String _name_1 = e.getName();
          boolean _equals = Objects.equal(_name, _name_1);
          if (_equals) {
            return false;
          }
        }
        EList<PojoEntity> _onlyPojos = ext.getOnlyPojos();
        boolean _isEmpty = _onlyPojos.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          EList<PojoEntity> _onlyPojos_1 = ext.getOnlyPojos();
          for (final PojoEntity ee_1 : _onlyPojos_1) {
            String _name_2 = ee_1.getName();
            String _name_3 = e.getName();
            boolean _equals_1 = Objects.equal(_name_2, _name_3);
            if (_equals_1) {
              return true;
            }
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
  
  public boolean isImplements(final PojoEntity e, final Implements ext) {
    EList<PojoEntity> _onlyPojos = ext.getOnlyPojos();
    boolean _isEmpty = _onlyPojos.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      EList<PojoEntity> _onlyPojos_1 = ext.getOnlyPojos();
      for (final PojoEntity ee : _onlyPojos_1) {
        String _name = ee.getName();
        String _name_1 = e.getName();
        boolean _equals = Objects.equal(_name, _name_1);
        if (_equals) {
          return true;
        }
      }
      return false;
    }
    EList<PojoEntity> _exceptPojos = ext.getExceptPojos();
    for (final PojoEntity ee_1 : _exceptPojos) {
      String _name_2 = ee_1.getName();
      String _name_3 = e.getName();
      boolean _equals_1 = Objects.equal(_name_2, _name_3);
      if (_equals_1) {
        return false;
      }
    }
    return true;
  }
  
  public ArrayList<Implements> getImplements(final PojoEntity e) {
    final ArrayList<Implements> list = new ArrayList<Implements>();
    EObject _eContainer = e.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    EList<EObject> _eContents = _eContainer_1.eContents();
    Iterable<Implements> _filter = Iterables.<Implements>filter(_eContents, Implements.class);
    for (final Implements ext : _filter) {
      boolean _isImplements = this.isImplements(e, ext);
      if (_isImplements) {
        list.add(ext);
      }
    }
    return list;
  }
}
