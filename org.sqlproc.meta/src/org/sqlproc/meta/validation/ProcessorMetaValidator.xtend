/*
 * generated by Xtext
 */
package org.sqlproc.meta.validation
import org.eclipse.xtext.validation.Check

import static org.sqlproc.plugin.lib.util.Constants.*

import java.lang.reflect.Modifier
import java.lang.reflect.ParameterizedType
import java.util.Collection
import java.util.List

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.scoping.IScopeProvider
import org.sqlproc.meta.processorMeta.Artifacts
import org.sqlproc.meta.processorMeta.Column
import org.sqlproc.meta.processorMeta.Constant
import org.sqlproc.meta.processorMeta.DatabaseColumn
import org.sqlproc.meta.processorMeta.DatabaseTable
import org.sqlproc.meta.processorMeta.FunctionDefinition
import org.sqlproc.meta.processorMeta.Identifier
import org.sqlproc.meta.processorMeta.MappingColumn
import org.sqlproc.meta.processorMeta.MappingRule
import org.sqlproc.meta.processorMeta.MetaSql
import org.sqlproc.meta.processorMeta.MetaStatement
import org.sqlproc.meta.processorMeta.OptionalFeature
import org.sqlproc.meta.processorMeta.PojoDefinition
import org.sqlproc.meta.processorMeta.ProcedureDefinition
import org.sqlproc.meta.processorMeta.ProcessorMetaPackage
import org.sqlproc.meta.processorMeta.Property
import org.sqlproc.meta.processorMeta.TableDefinition
import org.sqlproc.meta.util.Utils

import com.google.inject.Inject

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import org.eclipse.emf.common.util.URI
import org.sqlproc.plugin.lib.resolver.PojoResolverFactory
import org.sqlproc.plugin.lib.resolver.DbResolver
import org.sqlproc.plugin.lib.property.ModelProperty
import org.sqlproc.plugin.lib.util.CommonUtils

enum ValidationResult {
	OK, WARNING, ERROR
}

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ProcessorMetaValidator extends AbstractProcessorMetaValidator {

    @Inject
    PojoResolverFactory pojoResolverFactory

    @Inject
    DbResolver dbResolver

    @Inject
    IScopeProvider scopeProvider

    @Inject
    IQualifiedNameConverter qualifiedNameConverter

    @Inject
    ModelProperty modelProperty


    val F_TYPES = <String>newArrayList("set", "update", "values", "where", "columns", "set=opt", "where=opt")

    @Check
    def checkMetaSqlFtype(MetaSql metaSql) {
        if (metaSql.getFtype() == null)
            return;
        if (!findInListIgnoreCase(F_TYPES, metaSql.getFtype())) {
            error("Invalid ftype : " + metaSql.getFtype(), ProcessorMetaPackage.Literals.META_SQL__FTYPE)
        }
    }

    def findInListIgnoreCase(List<String> list, String value) {
        if (list == null)
            return false
        for (String item : list) {
            if (item.equalsIgnoreCase(value))
                return true
        }
        return false
    }
    
    @Check
    def checkUniqueMetaStatement(MetaStatement metaStatement) {
        if (!(metaStatement.rootContainer instanceof Artifacts))
            return
        val artifacts = metaStatement.rootContainer as Artifacts
        for (MetaStatement metaStmt : artifacts.getStatements()) {
            if (metaStmt != null && metaStmt !== metaStatement) {
	            if (equalsStatement(metaStatement, metaStmt)) {
	                error("Duplicate name : " + metaStatement.getName() + "[" + metaStatement.getType() + "]",
	                        ProcessorMetaPackage.Literals.META_STATEMENT__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkUniqueMappingRule(MappingRule mappingRule) {
        if (!(mappingRule.rootContainer instanceof Artifacts))
            return
        val artifacts = mappingRule.rootContainer as Artifacts
        for (MappingRule rule : artifacts.getMappings()) {
            if (rule != null && rule !== mappingRule) {
	            if (equalsRule(mappingRule, rule)) {
	                error("Duplicate name : " + mappingRule.getName() + "[" + mappingRule.getType() + "]",
	                        ProcessorMetaPackage.Literals.MAPPING_RULE__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkUniqueOptionalFeature(OptionalFeature optionalFeature) {
        if (!(optionalFeature.rootContainer instanceof Artifacts))
            return
        val artifacts = optionalFeature.rootContainer as Artifacts
        for (OptionalFeature feature : artifacts.getFeatures()) {
            if (feature != null && feature != optionalFeature) {
	            if (equalsFeature(optionalFeature, feature)) {
	                error("Duplicate name : " + optionalFeature.getName() + "[" + optionalFeature.getType() + "]",
	                        ProcessorMetaPackage.Literals.OPTIONAL_FEATURE__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkUniquePojoDefinition(PojoDefinition pojoDefinition) {
    	val URI uri = pojoDefinition.eResource?.URI
        if (isResolvePojo(pojoDefinition) && !checkClass(getClass(pojoDefinition), uri))
            error("Class name : " + getClass(pojoDefinition) + " not exists",
                    ProcessorMetaPackage.Literals.POJO_DEFINITION__NAME)
        if (!(pojoDefinition.rootContainer instanceof Artifacts))
            return
        val artifacts = pojoDefinition.rootContainer as Artifacts
        for (PojoDefinition definition : artifacts.getPojos()) {
            if (definition != null && definition !== pojoDefinition) {
	            if (pojoDefinition.getName().equals(definition.getName())) {
	                error("Duplicate name : " + pojoDefinition.getName(),
	                        ProcessorMetaPackage.Literals.POJO_DEFINITION__NAME)
	                return
	            }
            }
        }
    }


    def equalsStatement(MetaStatement statement1, MetaStatement statement2) {
        if (statement1 == null && statement2 == null)
            return true
        if (statement1 == null || statement1.getName() == null)
            return false
        if (statement2 == null || statement2.getName() == null)
            return false
        if (statement1.getName().equals(statement2.getName()) && statement1.getType().equals(statement2.getType())) {
            return equalsModifiers(statement1.getModifiers(), statement2.getModifiers())
        }
        return false
    }

    def equalsRule(MappingRule rule1, MappingRule rule2) {
        if (rule1 == null && rule2 == null)
            return true
        if (rule1 == null || rule1.getName() == null)
            return false
        if (rule2 == null || rule2.getName() == null)
            return false
        if (rule1.getName().equals(rule2.getName()) && rule1.getType().equals(rule2.getType())) {
            return equalsModifiers(rule1.getModifiers(), rule2.getModifiers())
        }
        return false
    }

    def equalsFeature(OptionalFeature feature1, OptionalFeature feature2) {
        if (feature1 == null && feature2 == null)
            return true
        if (feature1 == null || feature1.getName() == null)
            return false
        if (feature2 == null || feature2.getName() == null)
            return false
        if (feature1.getName().equals(feature2.getName()) && feature1.getType().equals(feature2.getType())) {
            return equalsModifiers(feature1.getModifiers(), feature2.getModifiers())
        }
        return false
    }

    def equalsModifiers(List<String> modifiers1, List<String> modifiers2) {
        val filteredModifiers1 = filteredModifiers(modifiers1)
        val filteredModifiers2 = filteredModifiers(modifiers2)
        if (filteredModifiers1 == null && filteredModifiers2 == null)
            return true
        if (filteredModifiers1 == null)
            return false
        if (filteredModifiers2 == null)
            return false
        if (filteredModifiers1.isEmpty() && filteredModifiers2.isEmpty())
            return true
        // Filtry musi byt disjunktni, pro jednu shodu je vysledek komparace kladny
        for (String modifier1 : filteredModifiers1)
            for (String modifier2 : filteredModifiers2)
                if (modifier1.equals(modifier2))
                    return true
        return false
    }

    def List<String> filteredModifiers(List<String> modifiers) {
        if (modifiers == null)
            return null
        val filteredModifiers = <String>newArrayList()
        modifiers.forEach[modifier |
            if (modifier.indexOf('=') < 0)
                filteredModifiers.add(modifier)
        ]
        return filteredModifiers
    }

    def checkClass(String className, URI uri) {
        if (className == null || pojoResolverFactory.getPojoResolver() == null)
            return true

        val clazz = pojoResolverFactory.getPojoResolver().loadClass(className, uri)
        return clazz != null
    }

    def isResolvePojo(EObject model) {
        if (pojoResolverFactory.getPojoResolver() == null
                || !pojoResolverFactory.getPojoResolver().isResolvePojo(model))
            return false
        return true

    }

    def isResolveDb(EObject model) {
        return dbResolver.isResolveDb(model)
    }

    def String getClass(PojoDefinition pojo) {
        if (pojo.getClassx() != null)
            return pojo.getClassx().getQualifiedName()
        return pojo.getClass_()
    }

    @Check
    def checkColumn(Column column) {
        if (!isResolvePojo(column))
            return
        val columnName = Utils.getName(column)
        if (Utils.isNumber(columnName))
            return;
        if (CommonUtils.skipVerification(column, modelProperty))
            return;

        val URI uri = column.eResource?.URI
        val statement = column.getContainerOfType(typeof(MetaStatement))
        val artifacts = statement.getContainerOfType(typeof(Artifacts))

        val pojoName = Utils.getTokenFromModifier(statement, COLUMN_USAGE)
        val pojo = if (pojoName != null) Utils.findPojo(qualifiedNameConverter, artifacts,
                scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), pojoName)
        val columnUsageClass = if (pojo != null) getClass(pojo)
        if (columnUsageClass != null) {
            switch (checkClassProperty(columnUsageClass, columnName, uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + columnName + "[" + columnUsageClass + "]",
                        ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
            case ValidationResult.ERROR:
            	checkColumnGType(statement, columnName, columnUsageClass)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check result class attribute : " + columnName, ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
        }
    }
    
    def checkColumnGType(MetaStatement statement, String columnName, String columnUsageClass) {
    	if (statement == null || statement.statement == null || statement.statement.sqls == null)
    		return;
    	for (stmt : statement.statement.sqls) {
    		if (stmt.col != null && stmt.col.columns != null && stmt.col.columns != null) {
				for (_col : stmt.col.columns) {
					if (_col.modifiers != null) {
						for (mod : _col.modifiers) {
							if (mod.indexOf('gtype') >= 0) {
				                warning("Problem property : " + columnName + "[" + columnUsageClass + "]",
                			        ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
                			    return
							}
						}
					}
				}
    		}
    		if (stmt.meta != null && stmt.meta.ifs != null) {
    			for (ifs : stmt.meta.ifs) {
    				if (ifs.sqls != null) {
				    	for (stmt2 : ifs.sqls) {
				    		if (stmt2.col != null && stmt2.col.columns != null && stmt2.col.columns != null) {
								for (_col : stmt2.col.columns) {
									if (_col.modifiers != null) {
										for (mod : _col.modifiers) {
											if (mod.indexOf('gtype') >= 0) {
								                warning("Problem property : " + columnName + "[" + columnUsageClass + "]",
                			    				    ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
                			    				return
											}
										}
									}
								}
				    		}
			    		}
    				}
    			}
    		}
    	}
		error("Cannot find property : " + columnName + "[" + columnUsageClass + "]",
        	ProcessorMetaPackage.Literals.COLUMN__COLUMNS)
    }

    @Check
    def checkIdentifier(Identifier identifier) {
        if (!isResolvePojo(identifier))
            return;
        if (CommonUtils.skipVerification(identifier, modelProperty))
            return;

        val URI uri = identifier.eResource?.URI
        val identifierName = identifier.getName()
        val statement = identifier.getContainerOfType(typeof(MetaStatement))
        val artifacts = statement.getContainerOfType(typeof(Artifacts))

        val pojoName = Utils.getTokenFromModifier(statement, IDENTIFIER_USAGE)
        val pojo = if (pojoName != null) Utils.findPojo(qualifiedNameConverter, artifacts,
                scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), pojoName)
        val identifierUsageClass = if (pojo != null) getClass(pojo)
        if (identifierUsageClass != null) {
            switch (checkClassProperty(identifierUsageClass, identifierName, uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + identifierName + "[" + identifierUsageClass + "]",
                        ProcessorMetaPackage.Literals.IDENTIFIER__NAME)
            case ValidationResult.ERROR:
		        error("Cannot find property : " + identifierName + "[" + identifierUsageClass + "]",
					ProcessorMetaPackage.Literals.IDENTIFIER__NAME)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check input form attribute : " + identifierName,
                    ProcessorMetaPackage.Literals.IDENTIFIER__NAME)
        }
    }
    
    @Check
    def checkConstant(Constant constant) {
        if (!isResolvePojo(constant))
            return;
        if (CommonUtils.skipVerification(constant, modelProperty))
            return;

        val URI uri = constant.eResource?.URI
        val statement = constant.getContainerOfType(typeof(MetaStatement))
        val artifacts = statement.getContainerOfType(typeof(Artifacts))

        val pojoName = Utils.getTokenFromModifier(statement, CONSTANT_USAGE)
        val pojo = if (pojoName != null) Utils.findPojo(qualifiedNameConverter, artifacts,
                scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), pojoName)
        val constantUsageClass = if (pojo != null) getClass(pojo)
        if (constantUsageClass != null) {
            switch (checkClassProperty(constantUsageClass, constant.getName(),uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + constant.getName() + "[" + constantUsageClass + "]",
                        ProcessorMetaPackage.Literals.CONSTANT__NAME)
            case ValidationResult.ERROR:
                error("Cannot find property : " + constant.getName() + "[" + constantUsageClass + "]",
                        ProcessorMetaPackage.Literals.CONSTANT__NAME)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check constant form attribute : " + constant.getName(),
                    ProcessorMetaPackage.Literals.CONSTANT__NAME)
        }
    }

    @Check
    def checkMappingColumn(MappingColumn column) {
        if (!isResolvePojo(column))
            return
        val columnName = Utils.getName(column)
        if (Utils.isNumber(columnName))
            return;
        if (CommonUtils.skipVerification(column, modelProperty))
            return;

        val URI uri = column.eResource?.URI
        val rule = column.getContainerOfType(typeof(MetaStatement))
        val artifacts = rule.getContainerOfType(typeof(Artifacts))

        val pojoName = Utils.getTokenFromModifier(rule, MAPPING_USAGE)
        val pojo = if (pojoName != null) Utils.findPojo(qualifiedNameConverter, artifacts,
                scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), pojoName)
        val mappingUsageClass = if (pojo != null) getClass(pojo)
        if (mappingUsageClass != null) {
            switch (checkClassProperty(mappingUsageClass, columnName, uri)) {
            case ValidationResult.WARNING:
                warning("Problem property : " + columnName + "[" + mappingUsageClass + "]",
                        ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS)
            case ValidationResult.ERROR:
				error("Cannot find property : " + columnName + "[" + mappingUsageClass + "]",
        			ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS)
            }
            return
        }

        if (pojoResolverFactory.getPojoResolver() != null) {
            error("Cannot check result class attribute : " + columnName,
                    ProcessorMetaPackage.Literals.MAPPING_COLUMN__ITEMS)
        }
    }

    @Check
    def checkMetaStatement(MetaStatement statement) {
        if (statement.getModifiers() == null || statement.getModifiers().isEmpty())
            return;
        if (CommonUtils.skipVerification(statement, modelProperty))
            return;

        val artifacts = statement.getContainerOfType(typeof(Artifacts))
        var index = 0
        for (String modifier : statement.getModifiers()) {
            var ix = modifier.indexOf('=')
            if (ix > 0) {
	            val key = modifier.substring(0, ix)
	            var value = modifier.substring(ix + 1)
	            if (IDENTIFIER_USAGE.equals(key)) {
	                val pojo = Utils.findPojo(qualifiedNameConverter, artifacts,
	                        scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + IDENTIFIER_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            } else if (COLUMN_USAGE.equals(key)) {
	                val pojo = Utils.findPojo(qualifiedNameConverter, artifacts,
	                        scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + COLUMN_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            } else if (CONSTANT_USAGE.equals(key)) {
	                val pojo = Utils.findPojo(qualifiedNameConverter, artifacts,
	                        scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + CONSTANT_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            } else if (TABLE_USAGE.equals(key)) {
	                var ix1 = value.indexOf('=')
	                if (ix1 >= 0)
	                    value = value.substring(0, ix1)
	                val table = Utils.findTable(qualifiedNameConverter, artifacts,
	                        scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__TABLES), value)
	                if (table == null) {
	                    error("Cannot find table : " + value + "[" + TABLE_USAGE + "]",
	                            ProcessorMetaPackage.Literals.META_STATEMENT__MODIFIERS, index)
	                }
	            }
	            index = index + 1
            }
        }
    }

    @Check
    def checkMappingRule(MappingRule rule) {
        if (rule.getModifiers() == null || rule.getModifiers().isEmpty())
            return;
        if (CommonUtils.skipVerification(rule, modelProperty))
            return;

        val artifacts = rule.getContainerOfType(typeof(Artifacts))
        var index = 0
        for (String modifier : rule.getModifiers()) {
            var ix = modifier.indexOf('=')
            if (ix > 0) {
	            val key = modifier.substring(0, ix)
	            val value = modifier.substring(ix + 1)
	            if (MAPPING_USAGE.equals(key)) {
	                val pojo = Utils.findPojo(qualifiedNameConverter, artifacts,
	                        scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__POJOS), value)
	                if (pojo == null) {
	                    error("Cannot find pojo : " + value + "[" + MAPPING_USAGE + "]",
	                            ProcessorMetaPackage.Literals.MAPPING_RULE__MODIFIERS, index)
	                }
	            }
	            index = index + 1
	        }
        }
    }

    def isNumber(String param) {
        if (param == null)
            return false
        var i = param.length() - 1
        while(i >= 0) {
            if (!Character.isDigit(param.charAt(i)))
                return false
            i = i - 1
        }
        return true
    }

    def isPrimitive(Class<?> clazz) {
        if (clazz == null)
            return true
        if (clazz == typeof(String))
            return true
        if (clazz == typeof(java.util.Date))
            return true
        if (clazz == typeof(java.sql.Date))
            return true
        if (clazz == typeof(java.sql.Time))
            return true
        if (clazz == typeof(java.sql.Timestamp))
            return true
        if (clazz == typeof(java.sql.Blob))
            return true
        if (clazz == typeof(java.sql.Clob))
            return true
        if (clazz == typeof(java.math.BigDecimal))
            return true
        if (clazz == typeof(java.math.BigInteger))
            return true
        return false
    }

    def ValidationResult checkClassProperty(String className, String property, URI uri) {
        if (property == null || isNumber(property) || pojoResolverFactory.getPojoResolver() == null)
            return ValidationResult.OK
        if (className == null)
            return ValidationResult.ERROR
        var descriptors = pojoResolverFactory.getPojoResolver().getPropertyDescriptors(className, uri)
        if (descriptors == null) {
            return ValidationResult.WARNING
        }
        var checkProperty = property
        var pos1 = checkProperty.indexOf('=')
        if (pos1 > 0) {
            var pos2 = checkProperty.indexOf('.', pos1)
            if (pos2 > pos1)
                checkProperty = checkProperty.substring(0, pos1) + checkProperty.substring(pos2)
        }
        var innerProperty = null as String
        pos1 = checkProperty.indexOf('.')
        if (pos1 > 0) {
            innerProperty = checkProperty.substring(pos1 + 1)
            checkProperty = checkProperty.substring(0, pos1)
        }
        val _checkProperty = checkProperty
        var innerDesriptor = descriptors.findFirst[descriptor |
            descriptor.name == _checkProperty
        ]
        if (innerDesriptor == null) {
            val clazz = pojoResolverFactory.getPojoResolver().loadClass(className, uri)
            if (clazz != null && Modifier.isAbstract(clazz.getModifiers()))
                return ValidationResult.WARNING
            return ValidationResult.ERROR
        }
        if (innerProperty != null) {
            var innerClass = innerDesriptor.getPropertyType()
            if (innerClass.isArray()) {
                val type = innerDesriptor.getReadMethod().getGenericReturnType() as ParameterizedType
                if (type.getActualTypeArguments() == null || type.getActualTypeArguments().length == 0)
                    return ValidationResult.WARNING
                innerClass = type.getActualTypeArguments().head as Class<?>
                if (isPrimitive(innerClass))
                    return ValidationResult.ERROR
                return checkClassProperty(innerClass.getName(), innerProperty, uri)
            } else if (typeof(Collection).isAssignableFrom(innerClass)) {
                val type = innerDesriptor.getReadMethod().getGenericReturnType() as ParameterizedType
                if (type.getActualTypeArguments() == null || type.getActualTypeArguments().length == 0)
                    return ValidationResult.WARNING
                innerClass = type.getActualTypeArguments().head as Class<?>
                if (isPrimitive(innerClass))
                    return ValidationResult.ERROR
                return checkClassProperty(innerClass.getName(), innerProperty, uri)
            } else {
                if (isPrimitive(innerClass))
                    return ValidationResult.ERROR
                return checkClassProperty(innerClass.getName(), innerProperty, uri)
            }
        }
        return ValidationResult.OK
    }

    @Check
    def checkUniqueProperty(Property property) {
        if (!(property.rootContainer instanceof Artifacts))
            return
        val artifacts = property.rootContainer as Artifacts
        for (Property prop : artifacts.getProperties()) {
            if (prop != null && prop !== property) {
	            if (prop.getName().equals(property.getName()) && !prop.getName().startsWith("pojogen")
	                    && !prop.getName().startsWith("database") && !prop.getName().startsWith("metagen")
	                    && !prop.getName().startsWith("daogen") && !prop.getName().startsWith("replace-all")) {
	                error("Duplicate name : " + property.getName(), ProcessorMetaPackage.Literals.PROPERTY__NAME)
	                return
	            }
            }
        }
    }

    @Check
    def checkTableDefinition(TableDefinition tableDefinition) {
        if (!(tableDefinition.rootContainer instanceof Artifacts))
            return
        val artifacts = tableDefinition.rootContainer as Artifacts
        for (TableDefinition table : artifacts.getTables()) {
            if (table != null && table !== tableDefinition) {
	            if (tableDefinition.getName().equals(table.getName())) {
	                error("Duplicate name : " + tableDefinition.getName() + "[table]",
	                        ProcessorMetaPackage.Literals.TABLE_DEFINITION__NAME)
	                return
				}
	           }
        }
        if (isResolveDb(tableDefinition) && !dbResolver.checkTable(tableDefinition, tableDefinition.getTable())) {
            error("Cannot find table in DB : " + tableDefinition.getTable(),
                    ProcessorMetaPackage.Literals.TABLE_DEFINITION__TABLE)
        }
    }

    @Check
    def checkProcedureDefinition(ProcedureDefinition procedureDefinition) {
        if (!(procedureDefinition.rootContainer instanceof Artifacts))
            return
        val artifacts = procedureDefinition.rootContainer as Artifacts
        for (ProcedureDefinition procedure : artifacts.getProcedures()) {
            if (procedure != null && procedure !== procedureDefinition) {
	            if (procedureDefinition.getName().equals(procedure.getName())) {
	                error("Duplicate name : " + procedureDefinition.getName() + "[procedure]",
	                        ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION__NAME)
	                return
	            }
	        }
        }
        if (isResolveDb(procedureDefinition)
                && !dbResolver.checkProcedure(procedureDefinition, procedureDefinition.getTable())) {
            error("Cannot find procedure in DB : " + procedureDefinition.getTable(),
                    ProcessorMetaPackage.Literals.PROCEDURE_DEFINITION__NAME)
        }
    }

    @Check
    def checkFunctionDefinition(FunctionDefinition functionDefinition) {
        if (!(functionDefinition.rootContainer instanceof Artifacts))
            return
        val artifacts = functionDefinition.rootContainer as Artifacts
        for (FunctionDefinition function : artifacts.getFunctions()) {
            if (function != null && function !== functionDefinition) {
	            if (functionDefinition.getName().equals(function.getName())) {
	                error("Duplicate name : " + functionDefinition.getName() + "[function]",
	                        ProcessorMetaPackage.Literals.FUNCTION_DEFINITION__NAME)
	                return
	            }
	    	}
        }
    }

    @Check
    def checkDatabaseColumn(DatabaseColumn databaseColumn) {
        if (!isResolveDb(databaseColumn))
            return
        var prefix = databaseColumn.getName()
        var columnName = null as String
        val pos = prefix.indexOf('.')
        if (pos > 0) {
            prefix = databaseColumn.getName().substring(0, pos)
            columnName = databaseColumn.getName().substring(pos + 1)
        } else {
            prefix = null
            columnName = databaseColumn.getName()
        }

        val statement = databaseColumn.getContainerOfType(typeof(MetaStatement))
        val artifacts = statement.getContainerOfType(typeof(Artifacts))
        val value = Utils.getTokenFromModifier(statement, TABLE_USAGE, prefix)
        val tableDefinition = if (value != null) Utils.findTable(qualifiedNameConverter, artifacts,
                scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__TABLES), value)
        val tableName = if (tableDefinition != null) tableDefinition.getTable()
        if (tableName == null || !dbResolver.checkColumn(databaseColumn, tableName, columnName)) {
            error("Cannot find column in DB : " + databaseColumn.getName() + "[" + tableName + "]",
                    ProcessorMetaPackage.Literals.DATABASE_COLUMN__NAME)
        }
    }

    @Check
    def checkDatabaseTable(DatabaseTable databaseTable) {
        if (!isResolveDb(databaseTable))
            return
        val statement = databaseTable.getContainerOfType(typeof(MetaStatement))
        val artifacts = statement.getContainerOfType(typeof(Artifacts))

        val tableName = databaseTable.getName()
        val tableDefinitions = Utils.getTokensFromModifier(statement, TABLE_USAGE).map[value |
        	Utils.findTable(qualifiedNameConverter, artifacts,
                    scopeProvider.getScope(artifacts, ProcessorMetaPackage.Literals.ARTIFACTS__TABLES), value)
        ]
        val tableDefinition = tableDefinitions.findFirst[it != null] 
        if (tableDefinition == null || !dbResolver.checkTable(databaseTable, tableName)) {
            error("Cannot find table in DB : " + tableName, ProcessorMetaPackage.Literals.DATABASE_TABLE__NAME)
        }
    }
    
}
